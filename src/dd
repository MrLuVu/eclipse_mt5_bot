def train_ai_model():
    """Addestra o aggiorna il modello AI usando trades_log.csv"""
    if not os.path.exists(TRADES_FILE):
        print(f"[ERRORE] File {TRADES_FILE} non trovato.")
        return
    
    df = pd.read_csv(TRADES_FILE)
    
    if "profit" not in df.columns:
        print("[ERRORE] Colonna 'profit' mancante in CSV.")
        return

    # Target: trade positivo o negativo
    df["target"] = (df["profit"] > 0).astype(int)

    # Features
    feature_cols = [
        "exec_price", "stop_loss", "take_profit", "risk", "rr_effective",
        "poi_tipo", "poi_direzione", "poi_timeframe", "poi_bottom", "poi_top",
        "trend", "range_high", "range_low", "buy_liquidity", "sell_liquidity"
    ]

    X = df[feature_cols].fillna(0)
    X_encoded = pd.get_dummies(X)
    encoded_columns = X_encoded.columns.tolist()  # Salva le colonne dopo encoding
    
    y = df["target"]

    # Train/test split
    X_train, X_test, y_train, y_test = train_test_split(
        X_encoded, y, test_size=0.2, random_state=42
    )

    # RandomForest
    model = RandomForestClassifier(n_estimators=200, random_state=42)
    model.fit(X_train, y_train)
    
    acc = model.score(X_test, y_test)
    print(f"[INFO] Modello addestrato. Accuracy su test set: {acc:.2f}")

    # Salva modello + informazioni colonne
    joblib.dump({
        "model": model, 
        "features": feature_cols,
        "encoded_columns": encoded_columns
    }, MODEL_FILE)
    
    print(f"[INFO] Modello salvato in {MODEL_FILE}")
    print(f"[INFO] Numero colonne dopo encoding: {len(encoded_columns)}")

def predict_live(new_trade_dict):
    """Restituisce probabilit√† che il nuovo trade sia positivo"""
    if not os.path.exists(MODEL_FILE):
        print("[INFO] Nessun modello salvato, avvio addestramento...")
        train_ai_model()
    
    # Carica modello e informazioni sulle features
    data = joblib.load(MODEL_FILE)
    model = data["model"]
    feature_cols = data["features"]  # Colonne originali
    encoded_columns = data["encoded_columns"]  # Colonne dopo one-hot encoding
    
    # Converti il dizionario in DataFrame mantenendo solo le colonne originali
    df_new = pd.DataFrame([new_trade_dict])
    
    # Seleziona solo le colonne presenti nel training originale
    df_new = df_new[feature_cols].fillna(0)
    
    # Applica one-hot encoding
    df_new_encoded = pd.get_dummies(df_new)
    
    # Allinea le colonne con quelle del training
    # Aggiungi colonne mancanti con valore 0
    for col in encoded_columns:
        if col not in df_new_encoded.columns:
            df_new_encoded[col] = 0
    
    # Mantieni solo le colonne presenti nel training e nello stesso ordine
    df_new_encoded = df_new_encoded[encoded_columns]
    
    # Predizione
    try:
        prob = model.predict_proba(df_new_encoded)[0][1]
        return prob
    except Exception as e:
        print(f"[ERRORE] nella predizione: {e}")
        print(f"Colonne attese: {len(encoded_columns)}")
        print(f"Colonne ottenute: {len(df_new_encoded.columns)}")
        print(f"Prime 10 colonne attese: {encoded_columns[:10]}")
        print(f"Prime 10 colonne ottenute: {df_new_encoded.columns.tolist()[:10]}")
        return 0.5  # Valore neutro in caso di errore


C:\Users\luigi\Desktop\eclipse_mt5_bot\ai_model.py:199: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
